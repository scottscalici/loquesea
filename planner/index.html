<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lego Dashboard 2026</title>
    <style>
        :root {
            --bg: #121212;
            --brick-blue: #3498db;
            --brick-purple: #9b59b6;
            --brick-orange: #e67e22;
            --text: #ffffff;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); padding: 20px; }
        .container { max-width: 800px; margin: auto; }
        .nav-bar { display: flex; gap: 10px; align-items: center; background: #222; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        #timeline { position: relative; width: 100%; border-left: 2px solid #333; margin-top: 20px; }
        #all-day-container { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
        .all-day-brick { background: #555; border-left: 8px solid #e67e22; border-radius: 8px; padding: 10px; font-size: 0.9em; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .brick { position: absolute; width: calc(100% - 40px); margin-left: 20px; border-radius: 8px; padding: 10px; border-left: 8px solid rgba(0,0,0,0.3); box-sizing: border-box; font-size: 0.9em; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .blue { background: var(--brick-blue); }
        .purple { background: var(--brick-purple); }
        .orange { background: var(--brick-orange); }

        /* Time Marker Red Line */
        #time-marker {
            position: absolute;
            width: 100%;
            border-top: 2px solid #ff4757;
            z-index: 100;
            pointer-events: none;
            transition: top 0.3s linear;
        }
        #time-marker::after {
            content: '‚óè';
            color: #ff4757;
            position: absolute;
            left: -10px;
            top: -9px;
            font-size: 18px;
        }

        /* Checklists & Reminders */
        .task-list { margin-top: 8px; padding-left: 0; list-style: none; font-size: 0.85em; }
        .task-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
        .task-item input[type="checkbox"] { cursor: pointer; accent-color: #2ecc71; }
        .add-reminder-btn { background: rgba(255,255,255,0.2); border: none; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 4px; cursor: pointer; margin-top: 5px; }
        
        .blue-meeting { background: #2980b9 !important; border: 2px solid #ffffff; width: calc(100% - 80px) !important; margin-left: 50px !important; z-index: 10; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <div class="nav-bar">
        <label for="date-picker">Navigate:</label>
        <input type="date" id="date-picker">
        <button onclick="changeDay(-1)">‚óÄ Prev</button>
        <button onclick="changeDay(1)">Next ‚ñ∂</button>
        <button onclick="goToToday()">Today</button>
    </div>
    <h2 id="day-header">Loading Schedule...</h2>
    <div id="all-day-container"></div>
    <div id="timeline"></div>
</div>

<script>
       const CONFIG = {
        scheduleUrl: 'https://raw.githubusercontent.com/scottscalici/loquesea/main/planner/schedule.json',
        calendarUrl: 'https://raw.githubusercontent.com/scottscalici/imagenes/main/planes/calendario.json',
        coziUrl: 'https://rest.cozi.com/api/ext/1103/f9f7020d-05c9-4720-b813-2155b4485be7/icalendar/feed/feed.ics',
        calendlyToken: 'eyJraWQiOiIxY2UxZTEzNjE3ZGNmNzY2YjNjZWJjY2Y4ZGM1YmFmYThhNjVlNjg0MDIzZjdjMzJiZTgzNDliMjM4MDEzNWI0IiwidHlwIjoiUEFUIiwiYWxnIjoiRVMyNTYifQ.eyJpc3MiOiJodHRwczovL2F1dGguY2FsZW5kbHkuY29tIiwiaWF0IjoxNzY5MjMzNzU5LCJqdGkiOiJlODY1MTVlYS1hOGRiLTQ5YjMtYmI5Ny1lOWU5ZWIzYTI1NmQiLCJ1c2VyX3V1aWQiOiIzMGZkMzdhYS1kMGUyLTQxODYtOTVkNi04MjU2NTYxMDczMWIifQ.lF3v1MUuFxrttIsaDu5yNCWI0UTN9Z7NvQI78IPyxnR3D5scFL7iCIyormTQdu9_GHp_pnnTJ5lGPiXtGKLWtg', 
        proxy: 'https://corsproxy.io/?',
        pixelsPerMinute: 1.5, 
        dayStartHour: 5 
    };

    let currentSelectedDate = new Date();

    function format12Hour(timeStr) {
        if (!timeStr) return "";
        let [h, m] = timeStr.split(':').map(Number);
        const ampm = h >= 12 ? 'PM' : 'AM';
        h = h % 12 || 12;
        return `${h}:${m.toString().padStart(2, '0')} ${ampm}`;
    }

    function renderBrick(start, end, title, colorClass, tasks = []) {
        const timeline = document.getElementById('timeline');
        const brick = document.createElement('div');
        const [hS, mS] = start.split(':').map(Number);
        const [hE, mE] = end.split(':').map(Number);
        const startMins = (hS - CONFIG.dayStartHour) * 60 + mS;
        const durationMins = (hE * 60 + mE) - (hS * 60 + mS);

        brick.className = `brick ${colorClass}`;
        brick.style.top = `${startMins * CONFIG.pixelsPerMinute}px`;
        brick.style.height = `${durationMins * CONFIG.pixelsPerMinute}px`;

        let html = `<strong>${format12Hour(start)} - ${format12Hour(end)}</strong><br>${title}`;
        html += `<ul class="task-list">`;
        if (tasks && tasks.length > 0) {
            tasks.forEach(task => {
                html += `<li class="task-item"><input type="checkbox"> <label>${task}</label></li>`;
            });
        }
        html += `</ul><button class="add-reminder-btn" onclick="addManualReminder(this)">+ Reminder</button>`;
        brick.innerHTML = html;
        timeline.appendChild(brick);
    }

    async function syncSchoolCycle(todayStr) {
        try {
            const isWeekend = currentSelectedDate.getDay() === 0 || currentSelectedDate.getDay() === 6;
            if (isWeekend) return; // Exit early ONLY for school blocks

            const [calRes, schedRes] = await Promise.all([
                fetch(CONFIG.calendarUrl),
                fetch(CONFIG.scheduleUrl)
            ]);
            const calData = await calRes.json();
            const schedule = await schedRes.json();
            const dayInfo = calData.map?.find(d => d.fecha === todayStr);
            const cycle = dayInfo?.ciclo; 

            if (schedule.hard_stops?.school_dropoff) {
                const dropoff = schedule.hard_stops.school_dropoff;
                const routine = schedule.definitions.routines[dropoff.trigger_routine];
                const wheelsUp = subtractMinutes(dropoff.time, dropoff.commute_minutes);
                const wakeUp = subtractMinutes(wheelsUp, routine.duration);
                renderBrick(wakeUp, wheelsUp, `üöÄ ${routine.label}`, "purple", routine.tasks || []);
            }

            const dayKey = cycle === "A" ? "A_Day" : (cycle === "B" ? "B_Day" : null);
            if (dayKey && schedule.days[dayKey]) {
                schedule.days[dayKey].forEach(brick => {
                    const temp = schedule.definitions.brick_templates[brick.template];
                    const endTime = brick.end || addMinutes(brick.start, brick.duration || 60);
                    renderBrick(brick.start, endTime, brick.label, temp?.color || "blue", brick.tasks || []);
                });
            }
        } catch (e) { console.error("School Cycle Error:", e); }
    }

function renderAllDayBrick(title) {
    const container = document.getElementById('all-day-container');
    const div = document.createElement('div');
    div.className = 'all-day-brick';
    div.innerHTML = `<strong>All Day</strong><br>${title}`;
    container.appendChild(div);
}
    
async function syncCozi(todayMatch, dow) {
    try {
        const res = await fetch(CONFIG.proxy + encodeURIComponent(CONFIG.coziUrl));
        let text = await res.text();

        // Unfold ICS line breaks
        text = text.replace(/\r\n /g, "");

        const vevents = text.split("BEGIN:VEVENT");

        function parseRRule(rrule) {
            const obj = {};
            rrule.split(";").forEach(p => {
                const [k, v] = p.split("=");
                obj[k] = v;
            });
            return obj;
        }
function getEndTime(block) {
    // DTEND with time
    const endMatch = block.match(/DTEND[:;](?:.*T)?(\d{2})(\d{2})/);
    if (endMatch) {
        return `${endMatch[1]}:${endMatch[2]}`;
    }

    // Fallback: DURATION (PT1H30M, PT45M, etc.)
    const durMatch = block.match(/DURATION:PT(?:(\d+)H)?(?:(\d+)M)?/);
    if (durMatch) {
        const hours = parseInt(durMatch[1] || 0, 10);
        const mins = parseInt(durMatch[2] || 0, 10);
        return { hours, mins };
    }

    return null;
}
function occursWithinDateRange(startDate, endDate, today) {
    // endDate in ICS is exclusive for all-day events
    return today >= startDate && today < endDate;
}
function getDateRange(block) {
    const startMatch = block.match(/DTSTART.*:(\d{8})/);
    const endMatch = block.match(/DTEND.*:(\d{8})/);

    if (!startMatch) return null;

    return {
        start: startMatch[1],
        end: endMatch ? endMatch[1] : startMatch[1]
    };
}

        function isExcluded(block) {
            return [...block.matchAll(/EXDATE[^:]*:(\d{8})/g)]
                .some(m => m[1] === todayMatch);
        }

        function occursToday(block) {
            const startDateMatch = block.match(/DTSTART.*:(\d{8})/);
            if (!startDateMatch) return false;
            const startDate = startDateMatch[1];

            if (isExcluded(block)) return false;

            const rruleMatch = block.match(/RRULE:(.*)/);
            if (!rruleMatch) {
                // one-time event
                return startDate === todayMatch;
            }

            const rrule = parseRRule(rruleMatch[1]);

            // UNTIL cutoff
            if (rrule.UNTIL && rrule.UNTIL.slice(0, 8) < todayMatch) return false;

            switch (rrule.FREQ) {
                case "DAILY":
                    return todayMatch >= startDate;

                case "WEEKLY":
                    if (!rrule.BYDAY) return false;
                    if (!rrule.BYDAY.split(",").includes(dow)) return false;
                    return todayMatch >= startDate;

                case "YEARLY":
                    return todayMatch.slice(4) === startDate.slice(4);

                default:
                    return false;
            }
        }

        vevents.forEach(block => {
            const summaryMatch = block.match(/SUMMARY:(.*)/);
            if (!summaryMatch) return;
            const summary = summaryMatch[1].trim();

            // Determine date span
const range = getDateRange(block);
if (!range) return;

// MULTI-DAY EVENT ‚Üí banner on every day
if (range.start !== range.end &&
    occursWithinDateRange(range.start, range.end, todayMatch)) {
    renderAllDayBrick(`üè† ${summary}`);
    return;
}

// SINGLE-DAY all-day event
const timeMatch = block.match(/DTSTART[:;](?:.*T)?(\d{2})(\d{2})/);
if (!timeMatch && range.start === todayMatch) {
    renderAllDayBrick(`üè† ${summary}`);
    return;
}

// NORMAL timed event (only if it actually occurs today)
if (!occursToday(block)) return;

// Timed rendering
const sTime = `${timeMatch[1]}:${timeMatch[2]}`;
const end = getEndTime(block);

if (typeof end === "string") {
    renderBrick(sTime, end, `üè† ${summary}`, "orange");
} else if (end && typeof end === "object") {
    const mins = end.hours * 60 + end.mins;
    renderBrick(sTime, addMinutes(sTime, mins), `üè† ${summary}`, "orange");
} else {
    renderBrick(sTime, addMinutes(sTime, 60), `üè† ${summary}`, "orange");
}

        });

    } catch (e) {
        console.error("Cozi Fetch/Parse Error:", e);
    }
}





    async function syncCalendly(todayStr) {
        if (!CONFIG.calendlyToken || CONFIG.calendlyToken.includes('PASTE')) return;
        try {
            const userRes = await fetch('https://api.calendly.com/users/me', { headers: { 'Authorization': `Bearer ${CONFIG.calendlyToken}` } });
            const userData = await userRes.json();
            const eventsRes = await fetch(`https://api.calendly.com/scheduled_events?user=${userData.resource.uri}&min_start_time=${todayStr}T00:00:00Z&max_start_time=${todayStr}T23:59:59Z`, {
                headers: { 'Authorization': `Bearer ${CONFIG.calendlyToken}` }
            });
            const eventsData = await eventsRes.json();
            eventsData.collection.forEach(event => {
                const s = new Date(event.start_time);
                if (s.toLocaleDateString('sv') === todayStr) {
                    const sTime = s.toLocaleTimeString('en-GB').slice(0,5);
                    const eTime = new Date(event.end_time).toLocaleTimeString('en-GB').slice(0,5);
                    renderBrick(sTime, eTime, `üìÖ ${event.name}`, "blue-meeting");
                }
            });
        } catch (e) { console.error("Calendly Error"); }
    }

    async function updateUI() {
        const todayStr = currentSelectedDate.toLocaleDateString('sv');
        const todayMatch = todayStr.replace(/-/g, '');
        const daysMap = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
        const currentDayOfWeek = daysMap[currentSelectedDate.getDay()];
        
        document.getElementById('timeline').innerHTML = '';
        document.getElementById('all-day-container').innerHTML = '';
        document.getElementById('date-picker').value = todayStr;
        document.getElementById('day-header').innerText = `Schedule for ${todayStr} (${currentDayOfWeek})`;

        // Run all three independently
        await syncSchoolCycle(todayStr); 
        await syncCozi(todayMatch, currentDayOfWeek);
        await syncCalendly(todayStr);

        renderRedLine();
    }

    function changeDay(offset) { currentSelectedDate.setDate(currentSelectedDate.getDate() + offset); updateUI(); }
    function goToToday() { currentSelectedDate = new Date(); updateUI(); }
    function addMinutes(t, m) { const [h, min] = t.split(':').map(Number); const d = new Date(); d.setHours(h, min + m); return d.toTimeString().slice(0, 5); }
    function subtractMinutes(t, m) { const [h, min] = t.split(':').map(Number); const d = new Date(); d.setHours(h, min - m); return d.toTimeString().slice(0, 5); }

    function renderRedLine() {
        const now = new Date();
        if (now.toLocaleDateString('sv') !== currentSelectedDate.toLocaleDateString('sv')) return;
        const elapsedMins = (now.getHours() - CONFIG.dayStartHour) * 60 + now.getMinutes();
        if (elapsedMins < 0 || now.getHours() >= 22) return;
        let marker = document.getElementById('time-marker') || document.createElement('div');
        marker.id = 'time-marker';
        document.getElementById('timeline').appendChild(marker);
        marker.style.top = `${elapsedMins * CONFIG.pixelsPerMinute}px`;
    }

    document.getElementById('date-picker').addEventListener('change', (e) => {
        currentSelectedDate = new Date(e.target.value + "T12:00:00");
        updateUI();
    });

    updateUI();
    setInterval(renderRedLine, 60000);

</script>
</body>
</html>
