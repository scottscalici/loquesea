<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lego Dashboard 2026</title>
    <style>
        :root {
            --bg: #121212;
            --brick-blue: #3498db;
            --brick-purple: #9b59b6;
            --brick-orange: #e67e22;
            --text: #ffffff;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); padding: 20px; }
        .container { max-width: 800px; margin: auto; }
        .nav-bar { display: flex; gap: 10px; align-items: center; background: #222; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        #timeline { position: relative; width: 100%; border-left: 2px solid #333; margin-top: 20px; }
        #all-day-container { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
        .all-day-brick { background: #555; border-left: 8px solid #e67e22; border-radius: 8px; padding: 10px; font-size: 0.9em; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .brick { position: absolute; width: calc(100% - 40px); margin-left: 20px; border-radius: 8px; padding: 10px; border-left: 8px solid rgba(0,0,0,0.3); box-sizing: border-box; font-size: 0.9em; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .blue { background: var(--brick-blue); }
        .purple { background: var(--brick-purple); }
        .orange { background: var(--brick-orange); }

        /* Time Marker Red Line */
        #time-marker {
            position: absolute;
            width: 100%;
            border-top: 2px solid #ff4757;
            z-index: 100;
            pointer-events: none;
            transition: top 0.3s linear;
        }
        #time-marker::after {
            content: '‚óè';
            color: #ff4757;
            position: absolute;
            left: -10px;
            top: -9px;
            font-size: 18px;
        }
.teaching {
    background: #e74c3c;
    border-left: 8px solid #c0392b;
}

.prep {
    background: #3498db;
    border-left: 8px solid #21618c;
}

.lunch {
    background: #000000;
    opacity: 0.85;
}

        /* Checklists & Reminders */
        .task-list { margin-top: 8px; padding-left: 0; list-style: none; font-size: 0.85em; }
        .task-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
        .task-item input[type="checkbox"] { cursor: pointer; accent-color: #2ecc71; }
        .add-reminder-btn { background: rgba(255,255,255,0.2); border: none; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 4px; cursor: pointer; margin-top: 5px; }
        
        .blue-meeting { background: #2980b9 !important; border: 2px solid #ffffff; width: calc(100% - 80px) !important; margin-left: 50px !important; z-index: 10; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <div class="nav-bar">
        <label for="date-picker">Navigate:</label>
        <input type="date" id="date-picker">
        <button onclick="changeDay(-1)">‚óÄ Prev</button>
        <button onclick="changeDay(1)">Next ‚ñ∂</button>
        <button onclick="goToToday()">Today</button>
    </div>
    <h2 id="day-header">Loading Schedule...</h2>
    <div id="all-day-container"></div>
    <div id="timeline"></div>
</div>

<script>
/* =========================
   GLOBAL CONFIG & MAPS
========================= */

const CONFIG = {
    scheduleUrl: 'https://raw.githubusercontent.com/scottscalici/loquesea/main/planner/schedule.json',
    calendarUrl: 'https://raw.githubusercontent.com/scottscalici/imagenes/main/planes/calendario.json',
    coziUrl: 'https://rest.cozi.com/api/ext/1103/f9f7020d-05c9-4720-b813-2155b4485be7/icalendar/feed/feed.ics',
    calendlyToken: 'eyJraWQiOiIxY2UxZTEzNjE3ZGNmNzY2YjNjZWJjY2Y4ZGM1YmFmYThhNjVlNjg0MDIzZjdjMzJiZTgzNDliMjM4MDEzNWI0IiwidHlwIjoiUEFUIiwiYWxnIjoiRVMyNTYifQ.eyJpc3MiOiJodHRwczovL2F1dGguY2FsZW5kbHkuY29tIiwiaWF0IjoxNzY5MjMzNzU5LCJqdGkiOiJlODY1MTVlYS1hOGRiLTQ5YjMtYmI5Ny1lOWU5ZWIzYTI1NmQiLCJ1c2VyX3V1aWQiOiIzMGZkMzdhYS1kMGUyLTQxODYtOTVkNi04MjU2NTYxMDczMWIifQ.lF3v1MUuFxrttIsaDu5yNCWI0UTN9Z7NvQI78IPyxnR3D5scFL7iCIyormTQdu9_GHp_pnnTJ5lGPiXtGKLWtg',
    proxy: 'https://corsproxy.io/?',
    pixelsPerMinute: 1.5,
    dayStartHour: 5
};

const TEMPLATE_ROLE_MAP = {
    class: "teaching",
    prep: "prep",
    routine: "lunch",
    work: "prep"
};

let renderedBricks = [];
    
const renderedCalendlyEvents = new Set();

let currentSelectedDate = new Date();

/* =========================
   TIME HELPERS
========================= */

function addMinutes(t, m) {
    const [h, min] = t.split(':').map(Number);
    const d = new Date();
    d.setHours(h, min + m);
    return d.toTimeString().slice(0, 5);
}

    function localDayToUTCWindow(dateStr) {
    const localStart = new Date(dateStr + "T00:00:00");
    const localEnd = new Date(dateStr + "T23:59:59");

    return {
        min: localStart.toISOString(),
        max: localEnd.toISOString()
    };
}

function subtractMinutes(t, m) {
    const [h, min] = t.split(':').map(Number);
    const d = new Date();
    d.setHours(h, min - m);
    return d.toTimeString().slice(0, 5);
}

function format12Hour(timeStr) {
    if (!timeStr) return "";
    let [h, m] = timeStr.split(':').map(Number);
    const ampm = h >= 12 ? 'PM' : 'AM';
    h = h % 12 || 12;
    return `${h}:${m.toString().padStart(2, '0')} ${ampm}`;
}

/* =========================
   RENDERING
========================= */

function renderBrick(start, end, title, colorClass, tasks = [], meta = {}) {
    const timeline = document.getElementById('timeline');
    const brick = document.createElement('div');

    const [hS, mS] = start.split(':').map(Number);
    const [hE, mE] = end.split(':').map(Number);

    const startAbs = hS * 60 + mS;
    const endAbs = hE * 60 + mE;

    const startMins = (hS - CONFIG.dayStartHour) * 60 + mS;
    const durationMins = endAbs - startAbs;

    brick.className = `brick ${colorClass}`;
    brick.style.top = `${startMins * CONFIG.pixelsPerMinute}px`;
    brick.style.height = `${durationMins * CONFIG.pixelsPerMinute}px`;

    let html = `<strong>${format12Hour(start)} ‚Äì ${format12Hour(end)}</strong><br>${title}`;
    if (tasks.length) {
        html += `<ul class="task-list">`;
        tasks.forEach(t => {
            html += `<li class="task-item"><input type="checkbox"> ${t}</li>`;
        });
        html += `</ul>`;
    }

    brick.innerHTML = html;
    timeline.appendChild(brick);

    // üîπ REGISTER BRICK FOR STACKING
   renderedBricks.push({
    el: brick,
    start: startAbs,
    end: endAbs,
    column: 0,
    totalColumns: 1,
    meta
});

}

function renderAllDayBrick(title) {
    const container = document.getElementById('all-day-container');
    const div = document.createElement('div');
    div.className = 'all-day-brick';
    div.innerHTML = `<strong>All Day</strong><br>${title}`;
    container.appendChild(div);
}

/* =========================
   SCHOOL SCHEDULE
========================= */

async function syncSchoolCycle(todayStr) {
    try {
        const isWeekend = [0, 6].includes(currentSelectedDate.getDay());
        if (isWeekend) {
    // Skip school blocks, but allow Cozi
    return;
}

        const [calRes, schedRes] = await Promise.all([
            fetch(CONFIG.calendarUrl),
            fetch(CONFIG.scheduleUrl)
        ]);

        const calData = await calRes.json();
        const schedule = await schedRes.json();

        const dayInfo = calData.map?.find(d => d.fecha === todayStr);
        const cycle = dayInfo?.ciclo;

        const dayKey = cycle === "A" ? "A_Day" : cycle === "B" ? "B_Day" : null;
        if (!dayKey) return;

        schedule.days[dayKey].forEach(b => {
            const endTime = b.end || addMinutes(b.start, b.duration || 60);
            const role = TEMPLATE_ROLE_MAP[b.template] || "teaching";
            renderBrick(b.start, endTime, b.label, role, b.tasks || []);
        });

    } catch (e) {
        console.error("School cycle error", e);
    }
}

/* =========================
   COZI CALENDAR
========================= */

async function syncCozi(todayMatch, dow) {
    try {
        const res = await fetch(CONFIG.proxy + encodeURIComponent(CONFIG.coziUrl));
        let text = (await res.text()).replace(/\r\n /g, "");

        const vevents = text.split("BEGIN:VEVENT");

        function parseRRule(rr) {
            const o = {};
            rr.split(";").forEach(p => {
                const [k, v] = p.split("=");
                o[k] = v;
            });
            return o;
        }

        function isExcluded(block) {
    const exDates = [...block.matchAll(/EXDATE[^:]*:(\d{8})/g)]
        .map(m => m[1]);
    return exDates.includes(todayMatch);
}

        function occursToday(block) {
    if (isExcluded(block)) return false;

    const startMatch = block.match(/DTSTART.*:(\d{8})/);
    if (!startMatch) return false;

    const startDate = startMatch[1];
    const rruleMatch = block.match(/RRULE:(.*)/);

    if (!rruleMatch) return startDate === todayMatch;

            const r = parseRRule(rruleMatch[1]);
            if (r.UNTIL && r.UNTIL.slice(0, 8) < todayMatch) return false;

            if (r.FREQ === "DAILY") return todayMatch >= startDate;
            if (r.FREQ === "WEEKLY" && r.BYDAY?.includes(dow)) return todayMatch >= startDate;

            return false;
        }

        function getEnd(block, start) {
            const dtEnd = block.match(/DTEND[:;](?:.*T)?(\d{2})(\d{2})/);
            if (dtEnd) return `${dtEnd[1]}:${dtEnd[2]}`;

            const dur = block.match(/DURATION:PT(?:(\d+)H)?(?:(\d+)M)?/);
            if (dur) {
                const mins = (parseInt(dur[1] || 0) * 60) + parseInt(dur[2] || 0);
                return addMinutes(start, mins);
            }

            return addMinutes(start, 60);
        }

        vevents.forEach(block => {
            const summaryMatch = block.match(/SUMMARY:(.*)/);
            if (!summaryMatch) return;

            const summary = summaryMatch[1].trim();
            const dateRange = block.match(/DTSTART.*:(\d{8}).*DTEND.*:(\d{8})/);

            if (dateRange) {
                if (todayMatch >= dateRange[1] && todayMatch < dateRange[2]) {
                    renderAllDayBrick(`üè† ${summary}`);
                }
                return;
            }

            if (!occursToday(block)) return;

            const timeMatch = block.match(/DTSTART[:;](?:.*T)?(\d{2})(\d{2})/);
            if (!timeMatch) {
                renderAllDayBrick(`üè† ${summary}`);
                return;
            }

            const start = `${timeMatch[1]}:${timeMatch[2]}`;
            const end = getEnd(block, start);
            renderBrick(start, end, `üè† ${summary}`, "orange");
        });

    } catch (e) {
        console.error("Cozi error", e);
    }
}

    /* =========================
   CALENDLY
========================= */


async function syncCalendly(todayStr) {
    if (!CONFIG.calendlyToken || CONFIG.calendlyToken === 'PASTE_IF_NEEDED') return;

    try {
        const userRes = await fetch(
            'https://api.calendly.com/users/me',
            { headers: { Authorization: `Bearer ${CONFIG.calendlyToken}` } }
        );
        const userData = await userRes.json();

        const { min, max } = localDayToUTCWindow(todayStr);

    const eventsRes = await fetch(
  `https://api.calendly.com/scheduled_events?user=${userData.resource.uri}&min_start_time=${min}&max_start_time=${max}`,
  { headers: { Authorization: `Bearer ${CONFIG.calendlyToken}` } }
);

    const eventsData = await eventsRes.json();

const [year, month, day] = todayStr.split('-').map(Number);

eventsData.collection.forEach(ev => {
    // ‚ùå Ignore canceled/rescheduled ghosts
    if (ev.status !== "active") return;

    const start = new Date(ev.start_time);

    // üîí Hard local date match
    if (
        start.getFullYear() !== year ||
        start.getMonth() + 1 !== month ||
        start.getDate() !== day
    ) {
        return;
    }

    const sTime = start.toLocaleTimeString('en-GB', {
        hour: '2-digit',
        minute: '2-digit'
    });

    const eTime = new Date(ev.end_time).toLocaleTimeString('en-GB', {
        hour: '2-digit',
        minute: '2-digit'
    });

    renderBrick(sTime, eTime, `üìÖ ${ev.name}`, "blue-meeting", [], {
    source: "calendly",
    nest: true
});


    } catch (e) {
        console.error("Calendly error", e);
    }
}

    
/* =========================
   UI / NAV
========================= */

function renderRedLine() {
    const now = new Date();
    if (now.toDateString() !== currentSelectedDate.toDateString()) return;

    const elapsed = (now.getHours() - CONFIG.dayStartHour) * 60 + now.getMinutes();
    if (elapsed < 0) return;

    let line = document.getElementById('time-marker');
    if (!line) {
        line = document.createElement('div');
        line.id = 'time-marker';
        document.getElementById('timeline').appendChild(line);
    }

    line.style.top = `${elapsed * CONFIG.pixelsPerMinute}px`;
}

async function updateUI() {
    const todayStr = currentSelectedDate.toLocaleDateString('sv');
    const todayMatch = todayStr.replace(/-/g, '');
    const dowMap = ['SU','MO','TU','WE','TH','FR','SA'];
    const dow = dowMap[currentSelectedDate.getDay()];

    document.getElementById('timeline').innerHTML = '';
    document.getElementById('all-day-container').innerHTML = '';
    document.getElementById('date-picker').value = todayStr;

    document.getElementById('day-header').innerText =
        `Schedule for ${todayStr} (${dow})`;

    renderedCalendlyEvents.clear();

    renderedBricks = [];

await syncSchoolCycle(todayStr);
await syncCozi(todayMatch, dow);
await syncCalendly(todayStr);

nestCalendlyMeetings();   // üîë before stacking
stackOverlappingBricks();

renderRedLine();
}

/* =========================
   NEST CALENDLY
========================= */

function nestCalendlyMeetings() {
    const prepBlocks = renderedBricks.filter(b =>
        b.el.classList.contains('prep')
    );

    renderedBricks
        .filter(b => b.meta?.nest)
        .forEach(meeting => {
            const parent = prepBlocks.find(p =>
                meeting.start >= p.start && meeting.end <= p.end
            );

            if (!parent) return;

            // Position relative to parent
            const offset =
                (meeting.start - parent.start) * CONFIG.pixelsPerMinute;
            const height =
                (meeting.end - meeting.start) * CONFIG.pixelsPerMinute;

            meeting.el.style.position = 'absolute';
            meeting.el.style.top = `${offset}px`;
            meeting.el.style.height = `${height}px`;
            meeting.el.style.left = '8px';
            meeting.el.style.width = 'calc(100% - 16px)';
            meeting.el.style.zIndex = 20;

            parent.el.appendChild(meeting.el);
            meeting.el.classList.add('nested');

            // Remove from stacking consideration
            meeting.stacked = true;
        });
}


    
/* =========================
   OVERLAPPING BRICKS
========================= */
function stackOverlappingBricks() {
    // Reset layout
    const stackable = renderedBricks.filter(b => !b.meta?.nest);  
    stackable.forEach(b => {
        b.column = 0;
        b.totalColumns = 1;
        b.el.style.left = '0';
        b.el.style.width = 'calc(100% - 40px)';
    });

    // Sort by start time
    const bricks = [...stackable].sort((a, b) => a.start - b.start);

    let group = [];

  function applyGroup(group) {
    if (group.length <= 1) {
        group.forEach(b => {
            b.el.style.left = '0';
            b.el.style.width = 'calc(100% - 40px)';
        });
        return;
    }

    group.forEach((brick, i) => {
        brick.column = i;
        brick.totalColumns = group.length;
    });

    group.forEach(b => {
        const width = 100 / b.totalColumns;
        b.el.style.width = `calc(${width}% - 12px)`;
        b.el.style.left = `${b.column * width}%`;
    });
}

    bricks.forEach(brick => {
        if (!group.length) {
            group.push(brick);
            return;
        }

        const overlaps = group.some(b =>
            brick.start < b.end && brick.end > b.start
        );

        if (overlaps) {
            group.push(brick);
        } else {
            applyGroup(group);
            group = [brick];
        }
    });

    applyGroup(group);
}

    
document.getElementById('date-picker').addEventListener('change', e => {
    currentSelectedDate = new Date(e.target.value + "T12:00");
    updateUI();
});
function changeDay(offset) {
    currentSelectedDate.setDate(currentSelectedDate.getDate() + offset);
    updateUI();
}

function goToToday() {
    currentSelectedDate = new Date();
    updateUI();
}

renderedBricks = [];
updateUI();
setInterval(renderRedLine, 60000);
</script>
</body>
</html>
